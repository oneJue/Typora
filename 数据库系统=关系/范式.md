## 数据库三大范式对数据冗余、更新异常、插入异常、删除异常等问题的解决情况



<table><tbody><tr><td><p><span><strong>范式作用</strong></span></p></td><td><span><strong>范式</strong></span></td><td><span><strong>定义</strong></span></td><td><span><strong>案例</strong></span></td><td><span><strong>数据冗余</strong></span></td><td><span><strong>更新异常</strong></span></td><td><span><strong>插入异常</strong></span></td><td><span><strong>删除异常</strong></span></td><td><span><strong>解决异常方案</strong></span></td></tr><tr><td rowspan="4"><span>消除数据冗余、更新异常、插入异常和删除异常。</span></td><td><span>1NF</span></td><td><span>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。<p>数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p><p>&nbsp; 不满足第一范式就不是关系型数据库！</p></span></td><td><span>&nbsp;假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，关键字为组合关键字(学号, 课程名称)，因为存在如下决定关系：<p>&nbsp;&nbsp;&nbsp; (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</p><p>&nbsp;&nbsp;&nbsp; 这个数据库表不满足第二范式，因为存在如下决定关系：</p><p>&nbsp;&nbsp;&nbsp; (课程名称) → (学分)</p><p>&nbsp;&nbsp;&nbsp; (学号) → (姓名, 年龄)</p><p>即存在组合关键字中的字段决定非关键字的情况。</p><p>&nbsp;&nbsp;&nbsp; 结论：属于1NF</p></span></td><td><span>同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</span></td><td><span>若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。</span></td><td><span>假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。</span></td><td><span>假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</span></td><td><span>把选课关系表SelectCourse改为如下三个表：<p>&nbsp;&nbsp;&nbsp; 学生：Student(学号, 姓名, 年龄)；</p><p>&nbsp;&nbsp;&nbsp; 课程：Course(课程名称, 学分)；</p><p>&nbsp;&nbsp;&nbsp; 选课关系：SelectCourse(学号, 课程名称, 成绩)。</p><p>&nbsp;&nbsp;&nbsp; 这样的数据库表是符合第二范式的，消除了数据冗余、更新异常、插入异常和删除异常。</p><p>&nbsp;&nbsp;&nbsp; 另外，所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。</p></span></td></tr><tr><td><span>2NF</span></td><td><span>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF<p>&nbsp; 表中的属性必须完全依赖于全部主键，而不是部分主键。所以只有一个主键的表如果符合第一范式，那一定是第二范式。</p></span></td><td><span>假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字"学号"，因为存在如下决定关系：<p>&nbsp;&nbsp;&nbsp; (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)</p><p>这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：</p><p>&nbsp;&nbsp;&nbsp; (学号) → (所在学院) → (学院地点, 学院电话)</p><p>即存在非关键字段"学院地点"、"学院电话"对关键字段"学号"的传递函数依赖。</p><p>&nbsp;&nbsp;&nbsp; 它也会存在数据冗余、更新异常、插入异常和删除异常的情况</p></span></td><td><span>同一个院校有n个学生，那么院校地点和院校电话就重复存储了n-1次</span></td><td><span>若更改了某个院校的地点，数据表中院校所属行的地点都要更新，否则就会出现不一致的情况</span></td><td><span>如果某个新的院校里没有学生，那么久无法将该院校插入数据库</span></td><td><span>如果删除了一个院校的所有学生，那么该院校也将被删除掉</span></td><td><span>&nbsp;把学生关系表分为如下两个表：<p>&nbsp;&nbsp;&nbsp; 学生：(学号, 姓名, 年龄, 所在学院)；</p><p>&nbsp;&nbsp;&nbsp; 学院：(学院, 地点, 电话)。</p><p>这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。</p></span></td></tr><tr><td><span>3NF</span></td><td><span>在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。<p>所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。</p></span></td><td><span>假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：<p>&nbsp;&nbsp;&nbsp; (仓库ID, 存储物品ID) →(管理员ID, 数量)</p><p>&nbsp;&nbsp;&nbsp; (管理员ID, 存储物品ID) → (仓库ID, 数量)</p><p>&nbsp;&nbsp;&nbsp; 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><p>&nbsp;&nbsp;&nbsp; (仓库ID) → (管理员ID)</p><p>&nbsp;&nbsp;&nbsp; (管理员ID) → (仓库ID)</p><p>即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下删除、插入、更新异常。</p></span></td><td><span>一个仓库存储n种物品，则仓库与管理员重复存储了n-1次</span></td><td><span>如果仓库换了管理员，则表中所有行的管理员ID都要修改。否则出现数据不一致</span></td><td><span>如果新建了一个仓库，但是它没有存储物资，那么就无法插入表</span></td><td><span>如果一个仓库下存储的物资都被删除了，那么仓库也将被删除掉</span></td><td><span>&nbsp;把仓库管理关系表分解为二个关系表：<p>&nbsp;&nbsp;&nbsp; 仓库管理：StorehouseManage(仓库ID, 管理员ID)；</p><p>&nbsp;&nbsp;&nbsp; 仓库：Storehouse(仓库ID, 存储物品ID, 数量)。</p><p>&nbsp;&nbsp;&nbsp; 这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。</p></span></td></tr><tr><td><span>BCNF</span></td><td><span>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式。</span></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>
 

- [王道考研复习指导获取：密码7281](https://url18.ctfile.com/f/22722418-803125355-edf378?p=7281)
- [专栏目录首页：【专栏必读】王道考研408计算机组成原理万字笔记、题目题型总结、注意事项、目录导航和思维导图](https://zhangxing-tech.blog.csdn.net/article/details/120664162?spm=1001.2014.3001.5502)

### 文章目录

- [一：常见的算数运算指令](#_7)
- [二：常见的逻辑运算指令](#_33)
- [三：其他类型指令](#_47)
- - [（1）数据传送类指令](#1_50)
  - [（2）控制流指令](#2_57)
  - - [A：无条件转移指令jmp](#Ajmp_80)
    - [B：条件转移指令jcondition](#Bjcondition_105)
- [四：选择语句的机器级表示](#_125)
- [五：循环语句的机器级表示](#_153)
- - [（1）使用条件转移指令实现循环](#1_155)
  - [（2）使用loop指令实现循环](#2loop_193)

# 一：常见的算数运算指令

**注意**：

- 除法中`s`作除数，被除数会被**提前放置**到`edx`和`eax`当中
- `edx:eax`：在进行除法运算之前，需要把被除数进行**位扩展**为64bit，所以需要两个寄存器

| 中文名 | 英文名 | 汇编指令 | 功能 |
| --- | --- | --- | --- |
| 加 | `add` | `add d,s` | 计算`d+s`，结果存入`d` |
| 减 | `subtract` | `sub d,s` | 计算`d-s`，结果存入`d` |
| 乘 | `multiply` | `mul d,s` 和`imul d, s` | 无符号数`d*s`和有符号数`d*s`，结果存入`d` |
| 除 | `divide` | `div d,s`和`idiv d,s` | 无符号数和有符号除法`edx:eax/s` ，其中商存入`eax`，余数存入`edx` |
| 取负数 | `negative` | `neg d` | 将`d`取负数，结果存入`d` |
| 自增 | `increase` | `inc d` | 也即`d++`，结果存入`d` |
| 自减 | `decrease` | `dec d` | 也即`d--`，结果存入`d` |

**举例**

- `sub eax, 10`：计算`eax-10`并存入`eax`
- `add byte ptr [var], 10`：`var`所指内存地址一字节值与10相加，结果存入`var`所指内存地址处

# 二：常见的逻辑运算指令

| 中文名 | 英文名 | 汇编指令 | 功能 |
| --- | --- | --- | --- |
| 与 | `and` | `and d,s` | 将`d`和`s`逐位相与，结果放回`d` |
| 或 | `or` | `or d,s` | 将`d`和`s`逐位相或，结果放回`d` |
| 非 | `not` | `not d` | 将`d`逐位取反，结果放回`d` |
| 异或 | `exclusive or` | `xor d,s` | 将`d`和`s`逐位异或，结果放回`d` |
| 左移 | `shift left` | `shl d,s` | 将`d`逻辑左移`s`位，结果放回`d` |
| 右移 | `shift rightft` | `shr d,s` | 将`d`逻辑右移`s`位，结果放回`d` |

# 三：其他类型指令

## （1）数据传送类指令

- `mov`：将第二个操作数\(寄存器的内容、内存中的内容或常数值\)**复制**到第一个操作数\(寄存器或内存\)。但不能用于直接从内存复制到内存
- `push`：将**操作数压入内存的栈**，常用于函数调用。ESP是栈顶，压栈前先将ESP值减4 \(栈增长方向与内存地址增长方向相反\)，然后将操作数压入ESP指示的地址
- `pop`：与push指令相反，pop 指令执行的是**出栈工作**，出栈前先将ESP指示的地址中的内容出栈，然后将ESP值加4

## （2）控制流指令

**指令指针寄存器IP（相当于ARM型CPU中的程序计数器PC）：x86处理器维持着一个指示当前执行指令的指令指针\(IP\)， 当一条指令执行后，此指针自动指向下一条指令。IP 寄存器不能直接操作，但可以用控制流指令更新。通常用标签\( label\)指示程序中的指令地址，在x86汇编代码中，可在任何指令前加入标签**

- `jmp`：**无条件转移指令**，控制IP转移到**label所指示的地址**\(从label中取出指令执行\)
- `jcondition`：**条件转移指令**，依据CPU状态字中的一系列条件状态转移。CPU状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等
- `comp/test`：`cmp`指令用于**比较两个操作数的值**，`test` 指令**对两个操作数进行逐位与运算**，这两类指今都不保存操作结果，仅根据运算结果**设置CPU状态字中的条件码**
- `call/ret`：**无条件转移指令**，分别用于实现子程序\(过程、函数等\)的调用及返回

**对于无条件转移指令`call/ret`，其过程调用的执行步骤如下，假设 P P P调用 Q Q Q**

- P P P将入口参数\(实参\)放在 Q Q Q能访问到的地方
- P P P将返回地址存到特定的地方，然后将控制转移到 Q Q Q
- Q Q Q保存 P P P的现场\(通用寄存器的内容\)，并为自己的非静态局部变量分配空间
- 执行过程 Q Q Q
- Q Q Q恢复 P P P的现场，将返回结果放到 P P P能访问到的地方，并释放局部变量所占空间
- Q Q Q取出返回地址，将控制转移到 P P P

### A：无条件转移指令jmp

**对于`jmp`指令，有如下四种使用方法**

 -    `jmp 128`：地址由常数给出
 -    `jmp eax`：地址可以来自于寄存器
 -    `jmp[999]`：地址可以来自于主存
 -    `jmp NEXT`：地址可以由“标号”给出，类似于C语言中的goto语句

```c
mov eax, 7
mov ebx, 6
jmp NEXT
mov ecx, ebx
NEXT:
mov ecx, eax
```

### B：条件转移指令jcondition

**`jmp`指令是很不灵活的，无法实现一些复杂条件转移操作，所以需要借助条件转移指令`jcondition`来完成，同时要借助`cmp a, b`（比较`a`和`b`的大小）**

 -    `je <地址>`：若`a == b` 则跳转（ZF == 1）
 -    `jne <地址>`：若 `a != b` 则跳转（ZF == 0）
 -    `jg <地址>`：若 `a > b` 则跳转（ZF == 0 \&\& SF == OF）
 -    `jge <地址>`：若 `a >= b` 则跳转（ SF == OF）
 -    `jl <地址>`：若 `a < b` 则跳转（ SF \!= OF）
 -    `jle <地址>`：若 `a <= b` 则跳转（ SF \!= OF || ZF == 1）

```c
cmp eax,ebx # 比较寄存器eax和ebx里的面的值
jg NEXT #若eax>ebx则跳转至NEXT位置处
```

# 四：选择语句的机器级表示

如下是C语言中的`if-else`语句

```c
if (a > b){
            
            
	c = a;
} else{
            
            
	c = b;
}
```

对应机器级表示如下

```bash
mov eax, 7  # 变量a=7，存入eax中
mov ebx, 6  # 变量b=6，存入ebx中
cmp eax, ebx  # 比较a和b
jg NEXT  # 若a>b，跳转至NEXT处
mov ecx, ebx  # 使用ecx存入变量c，使c=b
jmp END
NEXT:
mov ecx, eax  # 使用ecx存入变量c，使c=a
END：
```

# 五：循环语句的机器级表示

## （1）使用条件转移指令实现循环

**使用条件转移指令实现循环由以下4部分构成**

- 循环前的初始化
- 是否直接跳过循环
- 循环主体
- 是否继续循环

如下代码是C语言中的`for`循环，用于求解1+2+…+100

```c
int result = 0;
for(int i = 1; i <= 100; i++){
            
            
	result += i;
}
```

对应机器级表示如下

```bash
mov eax,0  # 使用eax保存result，初始值为0
mov edx,1  # 使用edx保存i，初始值为1

cmp edx,100 # 比较i和100的大小
jg L2 # 如果i>100，跳转至L2处

L1: # 循环主体
add eax,edx # result += i
inc edx # i++
cmp edx,100 # 比较i和100的大小
jle L1 # 如果i<=100，跳转至L1处

l2:  # 结束循环
```

## （2）使用loop指令实现循环

**从理论上讲，能用loop指令实现的功能也一定能用条件转移指令实现。loop指令的存在目的是为了使代码更加清晰、简洁，让其余分支语句区别更明显**

如下代码是C语言中的`for`循环，固定循环500次

```c
for(int i=500; i > 0; i--){
            
            
	do something;
}

```

对应机器级表示如下，其中

 -    `loop Looptop`：等价于`dec ecx`、`cmp ecx, 0`、`jne Looptop`

```bash
mov ecx, 500  # ecx是循环变量
Looptop:  # 循环开始
...
do something
...

loop Looptop  # ecx--，若ecx != 0，跳转至Looptop
```
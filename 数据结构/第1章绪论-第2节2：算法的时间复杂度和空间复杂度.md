

# 一：算法的时间复杂度

我们常常在说：**提高算法的效率**。这里的效率多数情况下指的就是**算法的执行时间**，那么如何度量呢？

## （1）事后统计方法

**事后统计方法：** 通过设计好的测试程序和数据，利用计算机计时器对不同算法编址的程序的运行时间进行比较，从而确定算法效率的高低。**这种算法很明显有很大缺陷**

- **事先编制程序**，这本就是费时费力的举动，如果最后测试出来证明它是糟糕的算法，那岂不是“赔了夫人又折兵”吗
- **程序运行特别依赖于软件和硬件，不同的测试环境会掩盖算法效率的真实性**。一个算法运行在超级计算机和运行在你的电脑上，其效率肯定是一个天上一个地下，这就不禁产生一个疑问，**运行时间短的算法究竟是占了物理机运算速度优势还是说这个算法本身效率就很高**？
- **算法的测试数据设计困难**。我们常常说程序有bug，这些bug很多都是一些非常规的输入导致的，但是你编写程序不可能一开始就把所有情况都考虑齐全了

## （2）事前分析估算的方法

**事前分析估算：在计算机程序编制之前，依据统计方法对算法进行估算**

我们发现，一个用高级程序语言编写的程序在计算机上运行消耗的时间常常取决于以下因素

1.  **算法采用的策略、方法**
2.  **编译产生的代码质量**
3.  **问题的输入规模**
4.  **机器执行指令的速度**

仍然以1+2+…+100为例，普通人的算法和高斯的算法区别如下

```c
//普通人
int i,sum=0,n=100; //执行1次
for(i=1;i<=n;i++)//执行n+1次
{
            
            
	sum=sum+i;//执行n次
}
cout << sum;//执行1次

//大神高斯
int sum=0,n=100;//执行1次
sum=(1+n)*n/2;//执行1次
cout << sum//执行1次
```

显然普通人的算法一共执行了1+\(n+1\)+n+1=2n+3次，而高斯的算法执行了1+1+1=3次。**这里我们把循环看作一个整体，两个算法其本质是n次和1次的差距，算法优劣之分显而易见**

**需要注意：我们分析程序的运行时间时，最重要的是要把程序看成独立于程序设计语言的算法或一系列步骤，不能束缚在特定的语言下考虑**

比如下面的例子中

```c
int i,j,x=0,sum=0,n=100;//执行一次
for(i=1;i<=n;i++)
{
            
            
	for(j=i;j<-n;j++)
	{
            
            
		x++;
		sum=sum+x;//执行了n×n次
	}
	cout << sum;//执行1次
}
```

`x++`和`sum=sum+x`在两个for循环的控制下要运行 10 0 2 100\^\{2\} 1002次，也就是 n 2 n\^\{2\} n2，**这个 n n n值我们称之为问题的规模， n n n越来越大，那么其在时间效率上的差异也就越来越大**

- 对于高斯的算法，输入规模为 n n n，其操作的量数就为 n n n
- 对于刚才的那个例子，输入规模为 n n n，其操作的量数就为 n 2 n\^\{2\} n2

## （3）函数的渐进式增长

**函数的渐进式增长：给定两个函数 f \( n \) f\(n\) f\(n\)和 g \( n \) g\(n\) g\(n\)，如果存在一个整数 N N N,使得对于所有的 n n n\> N N N， f \( n \) f\(n\) f\(n\)总是大于 g \( n \) g\(n\) g\(n\)，那么我们就说 f \( n \) f\(n\) f\(n\)的增长渐进快于 g \( n \) g\(n\) g\(n\)**（有种高数极限定义的味道）

比如下面几个算法的比较

| 次数 | A1\(2n+3\) | A2\(2n\) | B1\(3n+1\) | B2\(3n\) |
| ---- | ---------- | -------- | ---------- | -------- |
| n=1  | 5    | 2    | 4    | 3    |
| n=2  | 7    | 4    | 7    | 6    |
| n=3  | 9    | 6    | 10   | 9    |
| n=10 | 23   | 20   | 31   | 30   |
| n=100 | 203  | 200  | 301  | 300  |



- n=1时，A1效率不如B1
- n=2时，A1效率等于B1
- n>2时：A1效率开始优于B1
- n越来越大，A1效率越来越好

还有一点，大家也可以发现，对于A2和B2算法后面都是没有常数，**但是最终算法效率却大相近似，就像极限中的抓大头一样，我们完全可以忽略这些加法常数**

再来看下面的比较  
| 次数 | C1\(4 n n n+8\) | C2\( n n n\) | D1\(2 n 2 n\^\{2\} n2+1\) | D2\( n 2 n\^\{2\} n2\) |
| ---- | --------------- | ------------ | ------------------------- | ---------------------- |
| n=1  | 12   | 1    | 3    | 1    |
| n=2  | 16   | 2    | 9    | 4    |
| n=3  | 20   | 3    | 19   | 9    |
| n=10 | 48   | 10   | 201  | 100  |
| n=100 | 408  | 100  | 20001 | 10000 |
| n=1000 | 4008 | 1000 | 2000001 | 1000000 |



- n\<=3时，C1效率低于D1
- n>3时，C1效率开始优于D1

而且大家还会发现这样的结论：**即便去掉与最高次相乘的常数之后这样的效率关系也并不会改变**

再来看下面的比较  



| 次数 | E1\(2n 2 \^\{2\} 2+3n+1\) |E2\(n 2 \^\{2\} 2\) |F1\(2n 3 \^\{3\} 3+3n+1\)|F2\( n 3 n\^\{3\} n3\)|  
| ---- | --------------- | ------------ | ------------------------- | ---------------------- |
|n=1 | 6 |1|6|1|  
|n=2 | 15 |4|23|8|  
|n=3 | 28 |9|64|27|  
|n=10 | 231| 100|2031|1000|  
|n=100 |20301 |10000|2000301|1000000|




- n=1时，E1和F1效率一样
- n>1时，E1的效率开始优于F1

而且大家还会发现这样的结论：**最高次项的指数大的，函数随着n的增长，结果也会增长特别快**，其实判断一个算法的效率时，**主要看最高次项的阶数，如果最高次为3，那么对于常数和低于3次的次项就不需要考虑了**

## （4）算法时间复杂度

### A：算法时间复杂度定义-大 O O O记法

**算法时间复杂度：在进行算法分析时，语句总的执行次数 T \( n \) T\(n\) T\(n\)是关于问题规模 n n n的函数，进而分析 T \( n \) T\(n\) T\(n\)随 n n n的变化情况并确定 T \( n \) T\(n\) T\(n\)的数量级。算法的时间复杂度也就是算法的时间量度，记作： T \( n \) = O \( f \( n \) \) T\(n\)=O\(f\(n\)\) T\(n\)\=O\(f\(n\)\)。它表示随问题规模 n n n的增大，算法执行时间的增长率和 f \( n \) f\(n\) f\(n\)增长率相同，称作算法的渐进时间复杂度，简称时间复杂度，其中 f \( n \) f\(n\) f\(n\)是问题规模 n n n的某个函数——这样用 O \( \) O\(\) O\(\)体现时间复杂度的方法称之为大 O O O记法**

- O \( 1 \) O\(1\) O\(1\)叫做常数阶
- O \( n \) O\(n\) O\(n\)叫做线性阶
- O \( n 2 \) O\(n\^\{2\}\) O\(n2\)叫做平方阶

### B：推导大 O O O阶的方法

**推导基本方法如下**

- **用常数1取代运行时间中的所有加法常数**
- **在修改后的运行次数函数中，只保留最高项数**
- **如果最高项存在且不为1，则去除与这个项相乘的常数**

**其中：**

**O \( 1 \) O\(1\) O\(1\)\< O \( l o g 2 n \) O\(log\_\{2\}n\) O\(log2​n\)\< O \( n \) O\(n\) O\(n\)\< O \( n l o g 2 n \) O\(nlog\_\{2\}n\) O\(nlog2​n\)\< O \( n 3 \) O\(n\^\{3\}\) O\(n3\)\< O \( 2 n \) O\(2\^\{n\}\) O\(2n\)\< O \( n \! \) O\(n\!\) O\(n\!\)\< O \( n n \) O\(n\^\{n\}\) O\(nn\)（常对幂指）**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F644de73c76bb4bc981699f58c486e7b3.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121184939)

### C：各阶分析

#### ①：常数阶

高斯算法，很明显复杂度为 O \( 1 \) O\(1\) O\(1\)

```c
int sum=0,n=100;//执行1次
sum=(1+n)*n/2;//执行1次
cout << sum//执行1次
```

但是如果是这样呢？

```c
```c
int sum=0,n=100;//执行1次
sum=(1+n)*n/2;//执行1次
sum=(1+n)*n/2;//执行2次
sum=(1+n)*n/2;//执行3次
sum=(1+n)*n/2;//执行4次
sum=(1+n)*n/2;//执行5次
sum=(1+n)*n/2;//执行6次
sum=(1+n)*n/2;//执行7次
sum=(1+n)*n/2;//执行8次
sum=(1+n)*n/2;//执行9次
sum=(1+n)*n/2;//执行10次

cout << sum//执行1次
```

初学者很容易被其中置入的这些代码误导，**事实上，无论n为多少；两段代码就是3和12的区别，仍然属于常数阶，也就是 O \( 1 \) O\(1\) O\(1\)同时对于分支结构，无论是真是假，执行的次数都是恒定的，所以单纯的分支结构（不包含在循环中），其时间复杂度也是 O \( 1 \) O\(1\) O\(1\)**

#### ②：线性阶

此时分析时间复杂度时，**关键在于分析循环结构的运行情况**

如下代码由于循环体中的代码执行n次，因此其时间复杂度为 O \( n \) O\(n\) O\(n\)

```c
int i
for(i=0;i<n;i++)
{
            
            
	//时间复杂度为O(1)的程序步骤序列
}
```

#### ③：对数阶

如下代码，由于循环中`count`乘以2之后，距离循环结束条件的`n`就更近了一步，也就是说现在在问你：**有多少个2相乘后会大于n**，那么自然得到答案是 l o g 2 n log\_\{2\}n log2​n，所以时间复杂度是 O \( l o g 2 n \) O\(log\_\{2\}n\) O\(log2​n\)

#### ④：平方阶

如下例子，存在两个for循环，很明显其时间复杂度为 O \( m n \) O\(mn\) O\(mn\)，切当m=n时，时间复杂度为 O \( n 2 \) O\(n\^\{2\}\) O\(n2\)，所以 **循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数**

```c
int i,j;
for(i =0;i<m;i++)
{
            
            
	for(j=0;j<n;j++)
	{
            
            
		//时间复杂度为O(1)的程序步骤序列	
	}
}
```

下面的这个例子呢？和明显这是一个等差数列，n+\(n-1\)+\(n-2\)+…+1= n 2 2 \\frac\{n\^\{2\}\}\{2\} 2n2​+ n 2 \\frac\{n\}\{2\} 2n​，其时间复杂度仍然为 O \( n 2 \) O\(n\^\{2\}\) O\(n2\)

```c
int i,j;
for(i =0;i<m;i++)
{
            
            
	for(j=i;j<n;j++)//j是从i开始的
	{
            
            
		//时间复杂度为O(1)的程序步骤序列	
	}
}
```

另外还有一种情况较为常见，那就是递归，对于递归算法 **其时间复杂度为：递归次数\*每次递归的次数。** 下面例子时间复杂度为 O \( n \) O\(n\) O\(n\)

```c
// 计算阶乘递归Factorial的时间复杂度？
long long Factorial(size_t N)
{
            
            
	return N < 2 ? N : Factorial(N-1)*N;
}

```

### D：最好情况与最坏情况

如下是顺序查找算法的代码，大家会发现查找过程中有这样几种情形：

- 最好时间复杂度：第一次就找到了，时间复杂度为 O \( 1 \) O\(1\) O\(1\)
- 最坏时间复杂度，第n次才能找到，时间复杂度为 O \( n \) O\(n\) O\(n\)

那么其平均时间复杂度就是（假设元素出现在任意位置概率相同为 1 n \\frac\{1\}\{n\} n1​,查找次数为 n + 1 2 \\frac\{n+1\}\{2\} 2n+1​） O \( n \) O\(n\) O\(n\)

**而我们在描述算法的复杂度给出的是最坏情况，因为这已经是最坏的了，那么剩余的情况肯定就这个好**

```c
int search(NODE a[],int n, int k)
{
            
            
	int i=0;
	while(i++)
	{
            
            
		if(a[i].key==k)
			return i;
		else
			break;
	}
	return -1;
}
```

## （5）一些案例

**实例一：**

```c
// 计算Func2的时间复杂度？
void Func2(int N)
{
            
            
int count = 0;
for (int k = 0; k < 2 * N ; ++ k)
{
            
            
 
	++count;
}
int M = 10;
while (M--)
{
            
            
 
	++count;
}
printf("%d\n", count);
}
```

时间复杂度为：O\(N\)

**实例二：**

```c
// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
            
            
int count = 0;
for (int k = 0; k < M; ++ k)
{
            
            
 
	++count;
}
for (int k = 0; k < N ; ++ k)
{
            
            
 
	++count;
}
printf("%d\n", count);
}
```

若M远大于N则为：O\(N\)

实例三：

```c
// 计算Func4的时间复杂度？
void Func4(int N)
{
            
            
int count = 0;
for (int k = 0; k < 100; ++ k)
{
            
            
 
	++count;
}
printf("%d\n", count);
}
```

注意忽略常数项：O\(1\)

**实例四：**

```c
// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
            
            
	assert(a);
for (size_t end = n; end > 0; --end)
{
            
            
 
	int exchange = 0;
 
	for (size_t i = 1; i < end; ++i)
	 {
            
            
	 
		if (a[i-1] > a[i])
		 {
            
            
		 
			Swap(&a[i-1], &a[i]);
		 
		exchange = 1;
		 }
	 }
 
if (exchange == 0)
 
	break;
}
}
```

上述是冒泡排序的代码，这里要注意一点，不要认为嵌套循环的时间复杂度复杂度就是每次循环的次数之积。对于冒泡排序而言，每次排序，都把一个大数排到了最后，所以每趟排序结束之后，下次比较次数就减少一次，也就是1+2+3+4+5+6+·····+N-1,这是一个等差数列，计算其前N项和，得最坏情况的复杂度为**O\(N2\)** ，相应的最好情况就是**O（N）**

**实例五：**

```c
// 计算BinarySearch的时间复杂度？
int BinarySearch(int* a, int n, int x)
{
            
            
	assert(a);
	int begin = 0;
	int end = n-1;
	while(begin<end)
	{
            
            
		int mid=begin+((end-begin)>>1);
		if(a[mid]<x)
			begin=mid+1;
		else if(a[mid<x])
			end=mid;
		else
			return mid;
	}
	return -1;
}
```

这是二分查找算法，计算复杂度时不要被循环给误导了，计算时要领会算法的思想。二分查找在查找顺序表时，每次舍弃一半元素，查找一个元素就不断除以2，不断除以2，这样反向过来计算，想要查找到一个长度为N的顺序表中的某个元素时次数就是log2N，那么复杂度就**O\(log2N\)**

**实例六**

```c
// 计算阶乘递归Factorial的时间复杂度？
long long Factorial(size_t N)
{
            
            
	return N < 2 ? N : Factorial(N-1)*N;
}
```

这是使用递归计算N的阶乘  
对于递归算法，其时间复杂度为：**递归次数\*每次递归的次数**。  
故该算法的时间复杂度为**O\(N\)**。

**实例七**

```c
// 计算斐波那契递归Fibonacci的时间复杂度？
long long Fibonacci(size_t N)
{
            
            
	return N < 2 ? N : Fibonacci(N-1)+Fibonacci(N-2);
}
```

这是斐波那契数列的递归算法  
计算Fib\(N\)，就要计算Fib\(N-1\)+Fib\(N-2\)，同理要计算Fib\(N-1\)就要计算Fib\(N-2\)+Fib\(N-3\)，计算Fib\(N-2\)就要计算Fib\(N-3\)+Fib\(N-4\)·······  
比如N=5时，可以画出这样形象的图  
![肥美](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F20201203140426377.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121184939)  
学完二叉树后，就可以知道这是一颗满二叉树，对于一颗满二叉树每层高度上的结点数\(**这里结点数就代表斐波那契递归算法递归一次**\)为2k-1\(这里的k指的是高度\)，每层结点数加起来结果就是2n\-1（这里n指的是结点总数），于是斐波那契递归算法的时间复杂度为**O\(2N\)**  
这里要注意一下，斐波那契算法生成的满二叉树并不是真正的二叉树，上图中得到很明显的展示，右上角一定会要比左下角的先到1，但是对整体的时间复杂度并没有太大影响。  
可以发现计算斐波那契如果使用递归的算法，那么当N比较大时，时间复杂度将会指数级的增长，而且采用这种算法在计算时其实有一部分计算时完完全全重复了，完全就是在做无用功。所以我们可以采用迭代的方式实现

```c
#include <stdio.h>
#include <stdio.h>
#include <stddef.h>

long long* Fibonacci(size_t N)
{
            
            
	long long* fibArray = (long long*)malloc(sizeof(long long)*(N + 1));
	if (fibArray==NULL)
	{
            
            
		return -1;
	}
	fibArray[0] = 0;
	if (N == 0)
		return fibArray;
	fibArray[1] = 1;
	for (int i = 2; i <= N; i++)
	{
            
            
		fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
	}
	return fibArray[N];
}
int main()
{
            
            
	printf("%d\n", Fibonacci(50));
}
```

# 二：算法的空间复杂度

**算法的空间复杂度通过计算算法所需的存储空间来实现，算法空间复杂度的计算公式为 S \( n \) = O \( F \( n \) \) S\(n\)=O\(F\(n\)\) S\(n\)\=O\(F\(n\)\)其中, n n n为问题的规模， f \( n \) f\(n\) f\(n\)为语句关于 n n n所占存储空间的函数**

- 一般情况下，一个程序在机器上执行时，除了需要存储**程序本身的指令、常数、变量和输入数据外**，还需要存储堆数据操作的**存储单元**。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需要的辅助单元即可
- 若算法执行时所需要的辅助空间相对于输入数据量而言是一个**常数**，则称此算法为 **原地工作**，其空间复杂度为 O \( 1 \) O\(1\) O\(1\)

**实例一**

```c
// 计算BubbleSort的空间复杂度？
void BubbleSort(int* a, int n)
{
            
            
	assert(a);
	for (size_t end = n; end > 0; --end)
	 {
            
             
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		 {
            
            
			if (a[i-1] > a[i])
		    {
            
            
  				Swap(&a[i-1], &a[i]);
	        	exchange = 1;
	 	    }
		 }
	if (exchange == 0)	 
		break;
	 }
}
```

共定义了5个变量，故空间复杂度为O\(1\).  
**实例二**

```c
long long* Fibonacci(size_t n)
{
            
            
	if (n == 0)
		return NULL;
	long long * fibArray =
		(long long *)malloc((n + 1) * sizeof(long long));
	fibArray[0] = 0;
	fibArray[1] = 1; for (int i = 2; i <= n; ++i)
	{
            
            
		fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
	}
	return fibArray;
}
```

斐波那契数列开辟了N+1个空间，故空间复杂度为O\(N\)  
**实例三**

```c
// 计算阶乘递归Factorial的空间复杂度？
long long Factorial(size_t N)
{
            
            

	return N < 2 ? N : Factorial(N - 1)*N;
}
```

阶乘的递归算法递归调用了N次，开辟了N个栈帧，每个栈帧使用了常数个空间。空间复杂度为O\(N\)
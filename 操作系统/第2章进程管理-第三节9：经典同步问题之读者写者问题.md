 

- [指导获取：密码7281](https://url18.ctfile.com/f/22722418-803125355-edf378)
- [专栏目录首页：【专栏必读】王道考研408计算机网络+湖科大教书匠计算机网络+网络编程万字笔记、题目题型总结、注意事项、目录导航和思维导图](https://zhangxing-tech.blog.csdn.net/article/details/121004242?spm=1001.2014.3001.5502)
- [王道考研408计算机组成原理万字笔记](https://zhangxing-tech.blog.csdn.net/article/details/120664162?spm=1001.2014.3001.5502)
- [王道考研408数据结构+计算机算法设计与分析万字笔记](https://blog.csdn.net/qq_39183034/article/details/121501138?spm=1001.2014.3001.5501)
- [王道考研408计算机网络+湖科大教书匠计算机网络+网络编程万字笔记](https://zhangxing-tech.blog.csdn.net/article/details/125668174)

本文接

- [\(王道408考研操作系统\)第二章进程管理-第三节6：经典同步问题之生产者与消费者问题](https://blog.csdn.net/qq_39183034/article/details/121278992)
- [\(\(王道408考研操作系统\)第二章进程管理-第三节7：经典同步问题之多生产者与多消费者问题](https://blog.csdn.net/qq_39183034/article/details/121312323)
- [\(王道408考研操作系统\)第二章进程管理-第三节8：经典同步问题之吸烟者问题](https://blog.csdn.net/qq_39183034/article/details/121346179?spm=1001.2014.3001.5501)

---

### 文章目录

- [一：问题描述](#_16)
- [二：问题分析](#_33)
- [三：代码实现](#_59)

# 一：问题描述

读者和写者两组并发进程，共享一个文件，它们访问时有如下特点

- 多个读进程访问共享数据时不会产生副作用
- 如果某个写进程和其他进程（读进程或写进程）同时访问共享数据时，**会导致数据不一致的错误**

所以为了使访问正常进行，必须要求：

1.  允许**多个读者可以同时对文件执行读操作**
2.  **只允许一个写者向文件中写信息**
3.  任何一个写者在完成写操作之前**不允许其他读者或写者工作**
4.  写者执行写操作时，**应该让已有的读者和写者全部退出**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F25811e30e1db41ef9a6c0c2cafb27e89.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121367847)

# 二：问题分析

**关系分析：找出题目中描述的各个进程，分析它们之间的同步、互斥关系**

- **互斥关系：写进程与写进程；写进程与读进程**
- **同步关系：桌子上有组合一/二/三时，第一/二/三个抽烟者取走东西，这是三个同步关系；还有抽烟者抽完烟之后要发出完成信号，这是第四个同步关系**

**整理思路：根据各进程的操作流程确定P、V操作的大致顺序**

- **对于写者来说，它与任何进程都是互斥的，因此可以设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作**
- **对于读者进程，如果它也像前面那样，那么就不符合读者进程可以同时访问文件的要求了。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，所以我们可以让第一个访问文件的读进程“加锁”，也就是P操作，然后让最后一个访问完文件的读进程进行解锁，也就是V操作。所以可以设置一个整形变量count来记录当前有几个读进程在访问文件**
- **对于读进程来说，在某一时刻多个读进程并发执行。而我们对count变量的判断是无法实现原子性操作的，所以这里count就是一种临界资源了，需要对其进行保护，可以设置互斥信号量mutex**

**设置信号量：设置需要的信号量，并根据题目条件确定信号量初值**

 -    **设置信号量`count`为计数器，用于记录当前读者的数量，初值为0**；
 -    **设置`mutex`为互斥信号量，用于保护更新count变量时的互斥**；
 -    **设置互斥信号量`rw`，用于保证读者和写者的互斥访问**

```c
int count=0;
semaphore mutex=1;
semaphore rw=1;
```

# 三：代码实现

对于写者，在写文件之前进行P操作，写完之后进行V操作，就可以实现写者与其他进程的互斥

```c
writer()
{
            
            
	while(1)
	{
            
            
		P(rw);//写之前加锁
		写文件;
		V(rw);//写之后解锁
	}
}
```

对于读者，第一个读者进入会加锁，最后一个读者退出时进行解锁

```c
reader()
{
            
            
	while(1)
	{
            
            
		P(mutex);//使用P操作保护count，防止多个读进程对临界资源的操作
		if(count==0)
			P(rw);//第一个读进程
		count++;
		V(mutex);
		
		读文件;
		P(mutex);
		count--;
		if(count==0)
			V(rw);//最后一个读进程
		V(mutex);
		
	}
}
```

但是上面代码还存在一个bug：**读进程是优先，只要有读进程在读，写进程就会一直被阻塞，写进程饿死。**

所以如果希望写进程优先，**也就是说当有读进程在读时，若有写进程请求访问，那么应该禁止后续读进程请求，等到本次读进程完毕之后，立即让写进程执行，只有在无写进程的情况下才允许读进程再次运行。因此可以再增设一个信号量w，用于实现写优先**

```c
int count=0;
semaphore mutex=1;
semaphore rw=1;
semaphore w=1;//用于实现写优先


writer()
{
            
            
	while(1)
	{
            
            
		P(w);
		P(rw);//写之前加锁
		写文件;
		V(rw);//写之后解锁
		V(w);
	}
}

reader()
{
            
            
	while(1)
	{
            
            
		p(w);//在无写进程的情况下进入
		P(mutex);//使用P操作保护count，防止多个读进程对临界资源的操作
		if(count==0)
			P(rw);//第一个读进程
		count++;
		V(mutex);
		V(w);
		
		写文件;
		P(mutex);
		count--;
		if(count==0)
			V(rw);//最后一个读进程
		V(mutex);
		
	}
}
```

- 如果读者1、读者2陆续进入，由于没有写者进入，（reader中）因此后续读者也能够正常进入
- 如果写者1、写者2陆续进入，因此在writer中，第一个写者进入后会把第二写者阻塞
- 如果是写者1、读者1，那么在写者1进入后，读者1就无法进入，知道写者1释放资源
- 如果是读者1、写者1、读者2，那么在读者1执行完V\(w\)后，写者1不会被阻塞在P\(w\)，但是由于读者1执行了P\(rw\)，所以此时写者1会被阻塞在P\(rw\)处，而当读者2执行时，由于写者1已经执行了P\(w\)而没有执行V\(w\)，所以读者2会被阻塞P\(w\)处，直到读者1进行V\(rw\)后，所以写者1就会在P\(rw\)处唤醒，继续执行，但是读者2还是被阻塞在P\(w\)处，当写者1V\(w\)后，读者2便可以继续进行
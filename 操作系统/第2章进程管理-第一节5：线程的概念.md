 

- [指导获取：密码7281](https://url18.ctfile.com/f/22722418-803125355-edf378)
- [专栏目录首页：【专栏必读】王道考研408计算机网络+湖科大教书匠计算机网络+网络编程万字笔记、题目题型总结、注意事项、目录导航和思维导图](https://zhangxing-tech.blog.csdn.net/article/details/121004242?spm=1001.2014.3001.5502)
- [王道考研408计算机组成原理万字笔记](https://zhangxing-tech.blog.csdn.net/article/details/120664162?spm=1001.2014.3001.5502)
- [王道考研408数据结构+计算机算法设计与分析万字笔记](https://blog.csdn.net/qq_39183034/article/details/121501138?spm=1001.2014.3001.5501)
- [王道考研408计算机网络+湖科大教书匠计算机网络+网络编程万字笔记](https://zhangxing-tech.blog.csdn.net/article/details/125668174)

### 文章目录

- [一：线程的引入](#_15)
- [二：进程和线程](#_40)
- - [（1）什么是线程](#1_41)
  - [（2）引入线程机制后带来的变化](#2_45)
  - [（3）线程属性](#3_67)
  - [（4）补充：Linux中没有真正意义上的线程](#4Linux_85)
  - [（5）补充：轻量级进程（LWP）](#5LWP_96)
- [三：线程的优缺点](#_104)
- - [（1）优点](#1_105)
  - [（2）缺点](#2_115)
- [四：线程和进程对比](#_124)

**下面是一个关于“线程和进程区别”的视频，有助于帮助大家理解**

【操作系统】进程和线程的区别

# 一：线程的引入

---

**前面说过，创建一个进程通常会包含以下操作**

- 创建进程所需要的一系列数据结构
- 为它开辟物理内存，把代码和数据加载进物理内存
- 创建页表，负责映射
- ········

下图是三个进程，有各自的地址空间，**如果让第二个和第三个进程同时指向第一个进程的地址空间，此时这三个进程享有同一份地址空间**  
![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F20210413203334742.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F120983181)  
接着我们这份地址空间的代码段和数据段一分为三，**让这三个进程分别访问其中的某一块**  
![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F20210413204025672.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F120983181)  
**这样一来，进程1的地址空间就会出现三个执行流**

现在我们对进程的认识应该有所变化了，不能仅仅停留在前面说到过的PCB。**其实，上图中三个“进程”组成的整体才叫做进程，每一个“进程”是最终进程的一个执行流（线程）**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F20210413204946455.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F120983181)

# 二：进程和线程

## （1）什么是线程

**线程：线程是进程的一个执行流，处在进程的地址空间内，进程和线程的关系是1：n。引入线程后，进程是资源分配的基本单位，线程是调度的基本单位**

## （2）引入线程机制后带来的变化

**资源分配和调度方面：**

- **引入线程前**：**进程**是**资源分配和调度**的基本的单位
- **引入线程后**：进程是**资源分配**的基本单位，线程是**调度**的基本单位

**并发性方面：**

- **引入线程前**：只能**进程间并发**
- **引入线程后**：线程间也可以并发，**提高了并发度**

**系统开销：**

- **引入线程前**：进程切换**开销很大**
- **引入线程后**：**同一进程内的线程切换开销小**

## （3）线程属性

**线程属性：**

- 线程是**处理机调度**的单位
- 多CPU计算机中，**各个线程可占用不同的CPU**
- 每个线程都有一个线程ID、**线程控制块\(TCB\)**
- 线程也有**就绪、阻塞、运行**三种基本状态
- 线程**几乎不拥有**系统资源
- 同一进程的不同线程间**共享进程的资源**
- 由于共享内存地址空间，同一进程中的线程间通信甚至**无需系统干预**
- **同一进程中的线程切换**，不会引起进程切换；**不同进程中的线程切换**，会引起进程切换
- 切换**同进程内的线程**，系统开销很小
- 切换**进程**，系统开销较大

## （4）补充：Linux中没有真正意义上的线程

从之前的学习我们可以看到，对于抽象的东西，操作系统一定会用**相应的数据结构**进行管理。Windows在实现时的确为线程专门创建了数据结构，但Linux却另辟蹊径。**在Linux中没有像Windows中那样真实的数据结构来对线程管理，它是用进程模拟线程的**

- 为线程专门创建数据结构其实从效率上讲不是特别的好，因为线程的数量往往是大于进程的，这样一来这样的数据结构不止要维护线程和线程的关系，还要维护线程和进程的关系，结构越复杂，效率就越低

**因此在Linux中依旧采用`task_struct`来表示线程，如果有一个`task_struct`就表示这是有一个执行流的进程，如果有多个`task_struct`就表示这是有多个执行流的进程**

- **注意**：虽然是进程模拟线程，但是在Linux中仍然会有一些数据结构去维护这些信息，但是这样的结构体并不是真正意义上的专门维护线程的结构体，类似于`thread_control_block(TCB)`

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F20210413212004913.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F120983181)

## （5）补充：轻量级进程（LWP）

**轻量级进程（LWP）：在Linux中“没有进程，也没有线程”，你所看到的`task_struct`只不过是一个轻量级的进程（LWP）。它“重”是因为可能有很多其他的`task_struct`与它挂靠同一份地址空间，它“轻”是因为有可能它独享一份地址空间。从内核角度上看，它调度的基本单位是线程，也就是LWP**

# 三：线程的优缺点

## （1）优点

- **创建一个新线程的代价要比创建一个新进程小得多**
- **与进程之间的切换相比，线程之间的切换需要操作系统做的工作比较少**
- **线程占用的资源要比进程少得多**
- 能充分利用多处理器的可并行数量
- 在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
- 计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
- I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。

## （2）缺点

- **性能损失**：一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度的开销，而可用的资源不变
- **健壮性降低**：编写多线程需要更全面更深入的考虑，一个多线程程序里，因时间分配上的细微偏差或因共享了不该共享的变量而造成不良影响的可能性是很大的，或者说线程是缺乏保护的（**比如假如一个线程发生了除0错误，那么所有线程将会全部退出。因为线程是进程的执行分支，线程出现异常，其实进程也就出现了异常，从而触发了信号机制，终止进程，而进程一旦终止，资源都没有了，所以所有线程将会全部退出**）
- **缺乏访问控制**：进程是访问控制的基本粒度，在一个线程中调用某些系统调用函数会对整个进程造成影响
- **编程难度提高**：编写与调试（尤其是调试）一个多线程程序比单线程程序困难得多

# 四：线程和进程对比

- **引入进程：为了更好地使多道程序并发执行，提高资源利用率和系统的吞吐量**
- **引入线程：为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能**

**1：线程共享进程数据，但是也有自己的一部分数据**

- 线程ID
- **一组寄存器（硬件上下文）**
- **栈**
- errno
- 信号屏蔽字
- 调度优先级

**2：进程的多个线程共享地址空间，因此文本段，数据段都是共享的，所以一个全局变量多个线程都可以访问。除此之外，以下资源也是共享的**

- 文件描述符表
- 每种信号的处理方式
- 当前工作目录
- 用户ID和组ID

**3：进程和线程的关系可以用下面的图概括**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F69db5522c36c42f7b70040e350693cda.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5b-r5LmQ5rGf5rmW%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F120983181)
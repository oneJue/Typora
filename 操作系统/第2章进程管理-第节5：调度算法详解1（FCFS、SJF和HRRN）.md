 

- [指导获取：密码7281](https://url18.ctfile.com/f/22722418-803125355-edf378)
- [专栏目录首页：【专栏必读】王道考研408计算机网络+湖科大教书匠计算机网络+网络编程万字笔记、题目题型总结、注意事项、目录导航和思维导图](https://zhangxing-tech.blog.csdn.net/article/details/121004242?spm=1001.2014.3001.5502)
- [王道考研408计算机组成原理万字笔记](https://zhangxing-tech.blog.csdn.net/article/details/120664162?spm=1001.2014.3001.5502)
- [王道考研408数据结构+计算机算法设计与分析万字笔记](https://blog.csdn.net/qq_39183034/article/details/121501138?spm=1001.2014.3001.5501)
- [王道考研408计算机网络+湖科大教书匠计算机网络+网络编程万字笔记](https://zhangxing-tech.blog.csdn.net/article/details/125668174)

### 文章目录

- [一：先来先服务调度算法\(FCFS\)](#FCFS_15)
- [二：最短作业优先调度算法\(SJF\)和最短剩余时间优先算法（SRTN）](#SJFSRTN_57)
- - [（1）最短作业优先调度算法\(SJF\)](#1SJF_61)
  - [（2）最短剩余时间优先算法（SRTN）](#2SRTN_114)
- [三：高响应比优先调度算法\(HRRN\)](#HRRN_160)
- [总结](#_198)

**进程调度算法也称为CPU调度算法，调度算法种类非常多，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的两者都适用。常见的调度算法有（本节介绍适合于早期批处理系统的调度算法）：**

- 先来先服务调度算法（FCFS）
- 最短作业优先调度算法（SJF）
- 高响应比优先调度算法（HRRN）

# 一：先来先服务调度算法\(FCFS\)

**先来先服务调度算法\(FCFS\)：先来后到，每次从就绪队列选择最优先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续在队列中选择下一个进程，属于非抢占**

- **作业调度**：考虑的是哪个作业先到达后备队列
- **进程队列**：考虑的是哪个进程先到达就绪队列

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fcfa050c421fe433c9c327d0ea1dc517a.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)

**例如，下面有4个进程 P 1 P\_\{1\} P1​、 P 2 P\_\{2\} P2​、 P 3 P\_\{3\} P3​和 P 4 P\_\{4\} P4​，他们到达就绪队列的到达时间和运行时间如下表所示**

| 进程 | 到达时间 | 运行时间 |
| --- | --- | --- |
| P 1 P\_\{1\} P1​ | 0 | 7 |
| P 2 P\_\{2\} P2​ | 2 | 4 |
| P 3 P\_\{3\} P3​ | 4 | 1 |
| P 4 P\_\{4\} P4​ | 5 | 4 |

**很容易看到，在 F C F S FCFS FCFS算法下，按照到达的先后顺序进行调度，本质就是等待时间越久的进程越先得到服务**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F6f4574b346b74a3ea83e1f9c2a8f30db.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)

- **周转时间=完成时间-到达时间**： P 1 P\_\{1\} P1​\= 7 7 7\- 0 0 0\= 7 7 7、 P 2 P\_\{2\} P2​\= 11 11 11\- 2 2 2\= 9 9 9、 P 3 P\_\{3\} P3​\= 12 12 12\- 4 4 4\= 8 8 8、 P 4 P\_\{4\} P4​\= 16 16 16\- 5 5 5\= 11 11 11
- **带权周转时间=周转时间/运行时间**： P 1 P\_\{1\} P1​\= 7 7 7/ 7 7 7\= 1 1 1、 P 2 P\_\{2\} P2​\= 9 9 9/ 4 4 4\= 2.25 2.25 2.25、 P 3 P\_\{3\} P3​\= 8 8 8/ 1 1 1\= 8 8 8、 P 4 P\_\{4\} P4​\= 11 11 11/ 4 4 4\= 2.75 2.75 2.75
- **等待时间=周转时间-运行时间**： P 1 P\_\{1\} P1​\= 7 7 7\- 7 7 7\= 0 0 0、 P 2 P\_\{2\} P2​\= 9 9 9\- 4 4 4\= 5 5 5、 P 3 P\_\{3\} P3​\= 8 8 8\- 1 1 1\= 7 7 7、 P 4 P\_\{4\} P4​\= 11 11 11\- 4 4 4\= 7 7 7
- **平均周转时间：**： 7 + 9 + 8 + 11 4 = 8.75 \\frac\{7+9+8+11\}\{4\}=8.75 47+9+8+11​\=8.75
- **平均带权周转时间：**： 1 + 2.25 + 8 + 2.75 4 = 3.5 \\frac\{1+2.25+8+2.75\}\{4\}=3.5 41+2.25+8+2.75​\=3.5
- **平均等待时间：**： 0 + 5 + 7 + 7 4 = 4.75 \\frac\{0+5+7+7\}\{4\}=4.75 40+5+7+7​\=4.75

**优缺点**

- **优点：** 公平、算法实现简单
- **缺点：** 如果**带权周转时间很大，表明该进程只需很短的时间能被处理**，却还要花费很长时间处理。这就像你在屏幕上打字，明明是瞬间的事情，但是却要卡半天才能出来

**适用情况： F C F S FCFS FCFS对长作业有利，对短作业不利。适用于CPU繁忙型作业的系统，不适用于I/O繁忙型作业的系统**

**是否会导致饥饿现象：不会**

# 二：最短作业优先调度算法\(SJF\)和最短剩余时间优先算法（SRTN）

- **注意**：SRTN\$SJF的抢占式版本

## （1）最短作业优先调度算法\(SJF\)

**最短作业优先调度算法\(SJF\)：最短（要求服务时间最短）的作业/进程优先得到服务，既可以用于作业调度，也可以用于进程调度**

- 如果用于进程调度，又称为“**短进程优先算法（SPF）**”
- SPF和SJF都是**非抢占式算法**。但也有对应的抢占式版本，称之为**最短剩余时间优先算法（SRTN）**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fd9fe71ef901f4841b373157d98c78bc0.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)  
**比如，下面有4个进程 P 1 P\_\{1\} P1​、 P 2 P\_\{2\} P2​、 P 3 P\_\{3\} P3​和 P 4 P\_\{4\} P4​，他们到达就绪队列的到达时间和运行时间如下表所示**

| 进程 | 到达时间 | 运行时间 |
| --- | --- | --- |
| P 1 P\_\{1\} P1​ | 0 | 7 |
| P 2 P\_\{2\} P2​ | 2 | 4 |
| P 3 P\_\{3\} P3​ | 4 | 1 |
| P 4 P\_\{4\} P4​ | 5 | 4 |

**可以看出，在 S J F SJF SJF算法下，每次调度时选择当前已经到达且运行时间最短的进程**

- P 1 P\_\{1\} P1​先到达所以首先调度 P 1 P\_\{1\} P1​
- P 1 P\_\{1\} P1​运行“7”后， P 2 P\_\{2\} P2​、 P 3 P\_\{3\} P3​、 P 4 P\_\{4\} P4​均已到达，但是 P 3 P\_\{3\} P3​要求服务时间最短，所以下一次调度 P 3 P\_\{3\} P3​
- P 3 P\_\{3\} P3​运行后，对于 P 2 P\_\{2\} P2​、 P 4 P\_\{4\} P4​虽然要求服务时间一样，但是由于 P 2 P\_\{2\} P2​先到达，所以再调度 P 2 P\_\{2\} P2​
- 最后调度 P 4 P\_\{4\} P4​

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F6f9e6ae97aec4ecba4a995350548dd92.png&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)

- **周转时间=完成时间-到达时间**： P 1 P\_\{1\} P1​\= 7 7 7\- 0 0 0\= 7 7 7、 P 3 P\_\{3\} P3​\= 8 8 8\- 4 4 4\= 4 4 4、 P 2 P\_\{2\} P2​\= 12 12 12\- 2 2 2\= 10 10 10、 P 4 P\_\{4\} P4​\= 16 16 16\- 5 5 5\= 11 11 11
- **带权周转时间=周转时间/运行时间**： P 1 P\_\{1\} P1​\= 7 7 7/ 7 7 7\= 1 1 1、 P 3 P\_\{3\} P3​\= 4 4 4/ 1 1 1\= 4 4 4、 P 2 P\_\{2\} P2​\= 10 10 10/ 4 4 4\= 2.25 2.25 2.25、 P 4 P\_\{4\} P4​\= 11 11 11/ 4 4 4\= 2.75 2.75 2.75
- **等待时间=周转时间-运行时间**： P 1 P\_\{1\} P1​\= 7 7 7\- 7 7 7\= 0 0 0、 P 3 P\_\{3\} P3​\= 4 4 4\- 1 1 1\= 3 3 3、 P 2 P\_\{2\} P2​\= 10 10 10\- 4 4 4\= 6 6 6、 P 4 P\_\{4\} P4​\= 11 11 11\- 4 4 4\= 7 7 7
- **平均周转时间：**： 7 + 4 + 10 + 11 4 = 8 \\frac\{7+4+10+11\}\{4\}=8 47+4+10+11​\=8
- **平均带权周转时间：**： 1 + 4 + 2.5 + 2.75 4 = 2.56 \\frac\{1+4+2.5+2.75\}\{4\}=2.56 41+4+2.5+2.75​\=2.56
- **平均等待时间：**： 0 + 3 + 6 + 7 4 = 4 \\frac\{0+3+6+7\}\{4\}=4 40+3+6+7​\=4

**对比发现，各种时间都有所下降**

- **平均周转时间：**：由 F C F S FCFS FCFS的 8.75 8.75 8.75下降到了 S J F SJF SJF的 8 8 8
- **平均带权周转时间：**：由 F C F S FCFS FCFS的 3.5 3.5 3.5下降到了 S J F SJF SJF的 2.56 2.56 2.56
- **平均等待时间：**：由 F C F S FCFS FCFS的 4.75 4.75 4.75下降到了 S J F SJF SJF的 4 4 4

**优缺点**

- **优点：** “最短的”平均等待时间，平均周转时间
- **缺点：** 不公平。而且有时作业/进程的运行时间是由用户提供的，并不一定真实，不一定能够做到真正的短作业优先

**适用情况**： S J F SJF SJF**对短作业有利，对长作业不利**

**是否会导致饥饿现象：会**

- 如果短作业/进程源源不断到来，可能使长作业/进程长时间得不到服务，产生“饥饿“”现象，如果一直得不到服务则称之为“**饿死**”

## （2）最短剩余时间优先算法（SRTN）

**最短剩余时间优先算法（SRTN）：如果采用抢占式，那么就意味着在处理机中正在运行的进程会被剥夺下来。因此如果当前进程没有完成运行，那么一旦有进程进入就绪队列引起就绪队列改变时，就需要分析该进程是否会抢占处理机**

- 如果新到达的进程的**剩余时间**比当前运行的进程剩余时间**更短**，那么由**新进程抢占处理机，被强占的会回到就绪队列**
- 当进程主动放弃处理机（**进程完成**）时也需要调度

**比如，下面有4个进程 P 1 P\_\{1\} P1​、 P 2 P\_\{2\} P2​、 P 3 P\_\{3\} P3​和 P 4 P\_\{4\} P4​，他们到达就绪队列的到达时间和运行时间如下表所示，同时用那个 P n \( m \) P\_\{n\}\(m\) Pn​\(m\)表示当前进程 P n P\_\{n\} Pn​的剩余时间为 m m m**

| 进程 | 到达时间 | 运行时间 |
| --- | --- | --- |
| P 1 P\_\{1\} P1​ | 0 | 7 |
| P 2 P\_\{2\} P2​ | 2 | 4 |
| P 3 P\_\{3\} P3​ | 4 | 1 |
| P 4 P\_\{4\} P4​ | 5 | 4 |

**其变化过程如下**

- 首先 P 1 P\_\{1\} P1​到达，其剩余时间为 P 1 \( 7 \) P\_\{1\}\(7\) P1​\(7\)，**先调度 P 1 P\_\{1\} P1​**
- 运行2个时间后， P 2 P\_\{2\} P2​到达，此时 P 1 P\_\{1\} P1​剩余时间为 P 1 \( 5 \) P\_\{1\}\(5\) P1​\(5\)， P 2 P\_\{2\} P2​剩余时间为 P 2 \( 4 \) P\_\{2\}\(4\) P2​\(4\)，由于 P 2 \( 4 \) P\_\{2\}\(4\) P2​\(4\) \< P 1 \( 5 \) P\_\{1\}\(5\) P1​\(5\)，**因此 P 1 P\_\{1\} P1​被剥夺回到就绪队列，然后调度 P 2 P\_\{2\} P2​**
- 运行2个时间后， P 3 P\_\{3\} P3​到达，此时 P 1 P\_\{1\} P1​剩余时间为 P 1 \( 5 \) P\_\{1\}\(5\) P1​\(5\)， P 2 P\_\{2\} P2​剩余时间为 P 2 \( 2 \) P\_\{2\}\(2\) P2​\(2\)， P 3 P\_\{3\} P3​剩余时间为 P 3 \( 1 \) P\_\{3\}\(1\) P3​\(1\)，由于 P 3 \( 1 \) P\_\{3\}\(1\) P3​\(1\) \< P 2 \( 2 \) P\_\{2\}\(2\) P2​\(2\)，**因此 P 2 P\_\{2\} P2​被剥夺回到就绪队列，然后调度 P 3 P\_\{3\} P3​**
- 运行1个时间后， P 3 P\_\{3\} P3​完成而此时恰好 P 4 P\_\{4\} P4​到达，此时 P 1 P\_\{1\} P1​剩余时间为 P 1 \( 5 \) P\_\{1\}\(5\) P1​\(5\)， P 2 P\_\{2\} P2​剩余时间为 P 2 \( 2 \) P\_\{2\}\(2\) P2​\(2\)， P 4 P\_\{4\} P4​剩余时间为 P 4 \( 4 \) P\_\{4\}\(4\) P4​\(4\)，由于 P 2 \( 2 \) P\_\{2\}\(2\) P2​\(2\)最小，**因此在就绪队列中选择调度 P 2 P\_\{2\} P2​**
- 运行2个时间后， P 2 P\_\{2\} P2​完成，此时 P 1 P\_\{1\} P1​剩余时间为 P 1 \( 5 \) P\_\{1\}\(5\) P1​\(5\)，此时 P 4 P\_\{4\} P4​剩余时间为 P 4 \( 4 \) P\_\{4\}\(4\) P4​\(4\)，由于 P 4 \( 4 \) P\_\{4\}\(4\) P4​\(4\)最小，**因此在就绪队列中选择调度 P 4 P\_\{4\} P4​**
- 运行4个时间后， P 4 P\_\{4\} P4​完成，最后调度 P 1 P\_\{1\} P1​

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fa7c8e3ca7f7a470f868aaf3a98087f47.png&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)

- **周转时间=完成时间-到达时间**： P 1 P\_\{1\} P1​\= 16 16 16\- 0 0 0\= 16 16 16、 P 2 P\_\{2\} P2​\= 7 7 7\- 2 2 2\= 5 5 5、 P 3 P\_\{3\} P3​\= 5 5 5\- 4 4 4\= 1 1 1、 P 4 P\_\{4\} P4​\= 11 11 11\- 5 5 5\= 6 6 6（看表格）
- **带权周转时间=周转时间/运行时间**： P 1 P\_\{1\} P1​\= 16 16 16/ 7 7 7\= 2.28 2.28 2.28、 P 2 P\_\{2\} P2​\= 5 5 5/ 4 4 4\= 1.25 1.25 1.25、 P 3 P\_\{3\} P3​\= 1 1 1/ 1 1 1\= 1 1 1、 P 4 P\_\{4\} P4​\= 6 6 6/ 4 4 4\= 1.5 1.5 1.5
- **等待时间=周转时间-运行时间**： P 1 P\_\{1\} P1​\= 16 16 16\- 7 7 7\= 9 9 9、 P 2 P\_\{2\} P2​\= 5 5 5\- 4 4 4\= 1 1 1、 P 3 P\_\{3\} P3​\= 1 1 1\- 1 1 1\= 0 0 0、 P 4 P\_\{4\} P4​\= 6 6 6\- 4 4 4\= 2 2 2
- **平均周转时间：**： 16 + 5 + 1 + 6 4 = 7 \\frac\{16+5+1+6\}\{4\}=7 416+5+1+6​\=7
- **平均带权周转时间：**： 2.28 + 1.25 + 1 + 1.5 4 = 2 = 1.5 \\frac\{2.28+1.25+1+1.5\}\{4\}=2=1.5 42.28+1.25+1+1.5​\=2\=1.5
- **平均等待时间：**： 9 + 1 + 0 + 2 4 = 3 \\frac\{9+1+0+2\}\{4\}=3 49+1+0+2​\=3

**对比发现，各种时间都有所下降**

- **平均周转时间：** 由 S J F SJF SJF的 8 8 8下降到了 S R T N SRTN SRTN的 7 7 7
- **平均带权周转时间：** 由 S J F SJF SJF的 2.56 2.56 2.56下降到了 S R T N SRTN SRTN的 1.5 1.5 1.5
- **平均等待时间：** 由 S J F SJF SJF的 4 4 4下降到了 S R T N SRTN SRTN的 3 3 3

# 三：高响应比优先调度算法\(HRRN\)

- 可以看出：前面两种算法都没有很好的权衡**短作业**和**长作业**的问题

---

**高响应比优先调度算法\(HRRN\)：该算法综合考虑作业/进程的等待时间和要求服务的时间。在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其进行服务，属于非抢占**

- 如果两个进程的**等待时间相同，要求服务时间越短，那么响应比就会越高，这样短作业就容易被选中运行**
- 如果两个进程的**要求服务时间相同，等待时间越长，响应比就越高，这样长作业就容易被选中运行**  
  ![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F1ada3c86ccdc4eb3aec4f66e3a72a117.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)

**比如，下面有4个进程 P 1 P\_\{1\} P1​、 P 2 P\_\{2\} P2​、 P 3 P\_\{3\} P3​和 P 4 P\_\{4\} P4​，他们到达就绪队列的到达时间和运行时间如下表所示**

| 进程 | 到达时间 | 运行时间 |
| --- | --- | --- |
| P 1 P\_\{1\} P1​ | 0 | 7 |
| P 2 P\_\{2\} P2​ | 2 | 4 |
| P 3 P\_\{3\} P3​ | 4 | 1 |
| P 4 P\_\{4\} P4​ | 5 | 4 |

**其变化过程如下**

- 在0时刻，只有 P 1 P\_\{1\} P1​到达就绪队列，**所以 P 1 P\_\{1\} P1​上处理机**
- 在7时刻， P 1 P\_\{1\} P1​主动放弃CPU。此时就绪队列中 P 2 P\_\{2\} P2​其响应比为 5 + 4 4 = 2.25 \\frac\{5+4\}\{4\}=2.25 45+4​\=2.25、 P 3 P\_\{3\} P3​其响应比为 3 + 1 1 = 4 \\frac\{3+1\}\{1\}=4 13+1​\=4、 P 4 P\_\{4\} P4​其响应比为 2 + 4 4 = 1.5 \\frac\{2+4\}\{4\}=1.5 42+4​\=1.5，其中 P 3 P\_\{3\} P3​响应比最大，**所以调度 P 3 P\_\{3\} P3​**
- 在8时刻， P 3 P\_\{3\} P3​完成，此时 P 2 P\_\{2\} P2​其响应比为 6 + 4 4 = 2.5 \\frac\{6+4\}\{4\}=2.5 46+4​\=2.5、 P 4 P\_\{4\} P4​其响应比为 3 + 4 4 = 1.75 \\frac\{3+4\}\{4\}=1.75 43+4​\=1.75，其中 P 2 P\_\{2\} P2​响应比最大，**所以调度 P 2 P\_\{2\} P2​**
- 在12时刻， P 2 P\_\{2\} P2​完成，**最后调度 P 4 P\_\{4\} P4​**

---

# 总结

**上面这几种算法着重点主要在公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心响应时间，也不区分任务的紧急程度，因此交互性很差**

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fc45def3ddcdf4cd1b0a76d047aa415da.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5oiR5pOm5LqGREo%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F121071441)
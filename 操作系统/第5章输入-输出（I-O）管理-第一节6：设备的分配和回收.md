 

- [专栏目录首页：【专栏必读】王道考研408操作系统+Linux系统编程万字笔记、题目题型总结、注意事项、目录导航和思维导图](https://zhangxing-tech.blog.csdn.net/article/details/121004242?spm=1001.2014.3001.5502)

### 文章目录

- [一：设备分配时应该考虑的因素](#_8)
- - [（1）设备的固有属性](#1_9)
  - [（2）设备的分配算法](#2_24)
  - [（3）设备分配安全性](#3_28)
- [二：静态分配和动态分配](#_42)
- [三：设备分配管理中的数据结构](#_52)
- - [（1）设备控制表（DCT）](#1DCT_53)
  - [（2）控制器控制表（COCT）](#2COCT_65)
  - [（3）通道控制表（CHCT）](#3CHCT_77)
  - [（4）系统设备表（SDT）](#4SDT_89)
- [四：设备分配的步骤](#_97)
- [五：设备分配的步骤的改进](#_107)

**设备分配是指根据用户的I/O请求分配所需要的设备**

# 一：设备分配时应该考虑的因素

## （1）设备的固有属性

**独占式设备：是指在申请设备时，若设备空闲，则将其独占，不再允许其他进程申请使用，一直等到该设备被释放才允许其他进程申请使用**

- 例如打印机

**共享设备（分时共享）：可同时分配给多个进程使用，各个进程在宏观上是同时使用设备的，但在微观上是交替使用的**

- 例如磁盘

**虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用**

- 例如用SPOOLing技术实现的共享打印机

## （2）设备的分配算法

例如：先来先服务，优先级高者优先等等。具体可以参照相关文章

## （3）设备分配安全性

**安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。一个时段内每个进程仅能使用一个设备**

- **优点**：破坏了“请求和保持”条件，因此不会产生死锁
- **缺点**：对于一个进程来说，CPU和I/O设备只能串行工作

**不安全分配方式：进程发出I/O请求之后，系统为其分配I/O设备，进程可以继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备**

- **优点**：进程的计算任务和I/O任务可以并行处理，使进程迅速推进
- **缺点**：有可能会发生死锁（可以参照第二章的死锁避免，死锁检测和解除）

# 二：静态分配和动态分配

**静态分配：进程运行前为其分配全部所需要的资源，运行结束后归还资源**

- 由于破坏了“请求和保持”条件，所以不会发生死锁

**动态分配：进程运行过程中动态申请设备资源**

# 三：设备分配管理中的数据结构

## （1）设备控制表（DCT）

系统会为每一个设备配置一张**设备控制表（DCT）**，用于记录设备情况  
![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fc62b16e60bf2462ab2e20347f4e1b5ff.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5b-r5LmQ5rGf5rmW%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F122420101)

- **设备类型**：记录它是什么类型的设备
- **设备标识符**：也即物理设备名，系统中的每个设备的物理设备名唯一
- **设备状态**：有忙碌/空闲/故障等状态
- **指向控制器表的指针**：每个设备由一个设备控制器控制，通过该指针可以找到相应的控制器
- **重复执行的次数或时间**：当重复执行多次I/O操作仍然失败时，系统会认为此次I/O失败
- **设备队列的队首指针**：指向正在等待该失败的进程队列

## （2）控制器控制表（COCT）

每个设备控制器都会对应一张**控制器控制表（COCT）**，操作系统根据COCT的信息可以对控制器进行操作和管理

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fd8ff6acb630e4c9c828f9cd22ed61388.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5b-r5LmQ5rGf5rmW%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F122420101)

- **控制器标识符**：是各个控制器的唯一ID
- **控制器状态**：忙碌/空闲/故障
- **指向通道表的指针**：每个控制器由一个通道控制，该指针可以找到相应通道的信息
- **控制器队列的队首指针**
- **控制器队列的队尾指针**：指向正在等待该控制器的进程队列

## （3）通道控制表（CHCT）

每个通道都会对应一张**通道控制表（CHCT）**，操作系统根据CHCT的信息对通道进行管理

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2F636fd766d4204e5f89f426dc23d6a593.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5b-r5LmQ5rGf5rmW%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F122420101)

- **通道标识符**：各个通道的唯一ID
- **通道状态**：忙碌/空闲/故障
- **与通道连接的控制器表首址**：可通过该指针找到该通道管理的所有控制器（COCT）相关信息
- **通道队列的队首指针**
- **通道队列的队尾指针**：指向正在等待该通道的进程对垒

## （4）系统设备表（SDT）

**系统设备表（SDT）**记录了**系统中全部设备**的情况，每个设备对应一个表目

![在这里插入图片描述](https://ziquyun.com/main/csdn/img?url=https%3A%2F%2Fimg-blog.csdnimg.cn%2Fa3054930836d48d2b98c5e4962686bac.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5b-r5LmQ5rGf5rmW%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16&rfUrl=https%3A%2F%2Fzhangxing-tech.blog.csdn.net%2Farticle%2Fdetails%2F122420101)

# 四：设备分配的步骤

**设备分配步骤如下，只有设备、控制器、通道三者都分配成功时，分配才算成功，接着便可以启动I/O设备进行数据传送**

- 根据进程请求的**物理设备名**查找SDT
- 根据SDT找到DCT，若**设备**忙碌则将进程PCB挂到**设备等待队列**中，不忙碌则将**设备**分配个进程
- 根据DCT找到COCT，若**控制器**忙碌则将进程PCB挂到**控制器等待队列**中，不忙碌则将**控制器**分配给进程
- 根据COCT找到CHCT，若**通道**忙碌则将进程PCB挂到**通道等待队列**中，不忙碌则将**通道**分配给进程

# 五：设备分配的步骤的改进

上面设备分配的缺点在于

- 用户编程时必须使用物理设备名，底层细节对用户不透明，不便于编程
- 若用户更换了一个物理设备，则程序无法运行
- 若进程请求的物理设备正在忙碌，那么即使系统中还有同类型的设备，进程也必须要阻塞等待

---

**改进方法就是建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名**

- 根据进程请求的**逻辑设备名**查找SDT（用户编程时提供的逻辑设备名其实就是设备类型）
- 查找SDT，找到用户进程**指定类型且空闲的**设备，将其分配给进程。操作系统在**逻辑设备表（LUT）中新增一个表项**
- 根据DCT找到COCT，若**控制器**忙碌则将进程PCB挂到**控制器等待队列**中，不忙碌则将**控制器**分配给进程
- 根据COCT找到CHCT，若**通道**忙碌则将进程PCB挂到**通道等待队列**中，不忙碌则将**通道**分配给进程